# Лекція 12: ALTER та Міграції

---

## Теми лекції

- ALTER - модифікація структури бази даних
- Міграції баз даних
- Багатокроковий реліз

---

## 1. ALTER - модифікація структури бази даних

ALTER - це інструмент DDL (Data Definition Language) для оновлення вже створених структур, таких як таблиці, колонки, індекси тощо.

Приклад:
```sql
ALTER TABLE users ADD COLUMN age INTEGER;
```

### Як працює додавання колонки

Процес додавання нової колонки до таблиці складається з наступних кроків:

1. Отримання локу - отримується ACCESS EXCLUSIVE лок на табличку, що модифікується
2. Оновлення метаданих - виконується оновлення метаданих таблиці (дані в таблиці не змінюються)
3. Звільнення локу

Особливості процесу:
- Всі записи та читання з таблиці блокуються протягом всього процесу
- Початок процесу очікує закінчення всіх поточних операцій
- Вже існуючі дані в таблиці не змінюються
- Операція швидка (зазвичай кілька мілісекунд)

### Як працює додавання constraint до колонки

Додавання обмеження до існуючої колонки є більш складним процесом:

1. Отримання локу - отримується ACCESS EXCLUSIVE лок на табличку
2. Перевірка даних - виконується читання всіх даних в табличці та перевірка відповідності новому обмеженню
3. Оновлення метаданих - виконується оновлення метаданих таблиці (дані не змінюються)
4. Звільнення локу

Особливості:
- Всі записи та читання блокуються протягом всього процесу
- Початок процесу очікує закінчення всіх поточних операцій
- Вже існуючі дані в таблиці не змінюються
- Відбувається читання та перевірка на відповідність новому обмеженню ВСІХ даних в таблиці

### Безпечні (швидкі) ALTER операції

Ці операції виконуються швидко і не блокують таблицю на тривалий час:

1. Додавання колонки (може залежати від версії PostgreSQL)
2. Видалення колонки
3. Переіменування колонки
4. Додавання значення за замовчуванням для колонки
5. `CREATE INDEX CONCURRENTLY`

### Небезпечні (повільні) ALTER операції

Ці операції можуть тривати довго та блокувати доступ до таблиці:

1. Додавання CHECK / NOT NULL для існуючої колонки - провокує читання і перевірку всіх даних таблички
2. Зміна типу колонки - провокує переписування даних таблички
3. CREATE INDEX (без CONCURRENTLY) - блокує записи в табличку протягом створення індексу

---

## 2. Міграції баз даних

### Визначення

Міграції - це версіоновані послідовні зміни структури бази даних.

### Основні властивості міграцій

1. Чітка послідовність - кожна наступна міграція будується на попередніх
2. Версіонування - кожна міграція має послідовну версію
3. Повторюваність - після виконання заданого набору міграцій база даних завжди приходить до однієї і тієї ж структури
4. Відстежуваність - база даних зберігає інформацію про усі виконані міграції

### Складові частини системи міграцій

1. Версіонована послідовність міграцій - SQL скрипти чи інструменти фреймворків
2. Таблиця версій - таблиця в базі даних, що містить інформацію про виконані міграції
3. Інструмент виконання міграцій - Flyway / Liquibase / Prisma / Alembic / etc.

### Що можуть містити скрипти міграцій

- Створення / видалення / зміна таблиць
- Додавання / видалення / зміна колонок
- Додавання / видалення / оновлення індексів
- Інші зміни схеми бази даних
- Додавання / видалення / зміна даних в таблицях

### Базовий алгоритм системи міграцій

1. Порівнюється список файлів міграцій зі списком виконаних міграцій
2. Для кожної з виконаних міграцій по черзі:
    1. Обчислюється чек-сума файлу міграції
    2. Порівнюється фактична чек-сума міграції та чек-сума записана в таблиці версій
    3. Якщо вони не співпадають - повертається помилка та процес виконання міграцій скасовується
3. Для кожної з ще не виконаних міграцій по черзі:
   1. Обчислюється чек-сума міграції
   2. Починається транзакція
   3. Виконується скріпт міграції
   4. В таблицю версій додається версія та чек-сума
   5. Відбувається комміт транзакції

### Структура таблиці версій

Спрощений приклад структури таблиці schema_migrations:

```sql
CREATE TABLE IF NOT EXISTS schema_migrations (
    version VARCHAR(50) PRIMARY KEY,
    name VARCHAR(255) NOT NULL,
    applied_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    checksum VARCHAR(64),
    execution_time_ms INTEGER,
    success BOOLEAN DEFAULT TRUE
);
```

Поля таблиці:
- `version` - унікальний ідентифікатор міграції - версія
- `name` - назва міграції
- `applied_at` - timestamp виконання міграції
- `checksum` - чек-сума контенту файлу міграції
- `execution_time_ms` - час виконання в мілісекундах
- `success` - чи успішно виконана міграція

### Приклад файлу міграції

Ім'я файлу (синтаксис Flyway):
```
V015__add_user_age_column.sql
```

Контент файлу:
```sql
ALTER TABLE users ADD COLUMN age INTEGER;
```

У цьому прикладі:
- Версія міграції: 015
- Назва міграції: add user age column

### Чек-сума міграції

Чек-сума - це хеш всього контенту файлу міграції.

Навіщо потрібна чек-сума:
- Для перевірки того, що файл міграції не був змінений з часу її виконання

Чому це важливо:
- **Всі файли міграцій повинні бути повністю незмінними**
- Якщо міграція була виконана - це фіксований стан бази даних
- Стан можна повністю повторити в будь-який момент за допомогою виконання всіх попередніх та даної міграцій
- Якщо файли міграцій змінюються - повторюваності досягнути не вдасться

### Обробка помилок міграції

Що відбувається при помилці:
- Якщо стається будь-яка помилка - міграція позначається в таблиці версій як неуспішна
- Після цього виконання усіх наступних міграцій є неможливим

Для усунення проблеми потрібне ручне втручання:
1. Зрозуміти що пішло не так (прочитати логи виконання міграції)
2. Виправити проблему, що виникла
3. Видалити з таблиці міграцій інформацію про неуспішну міграцію або явно позначити міграцію як таку, що була виконана успішно
4. Повторити міграцію (пропустити цей крок, якщо було явно позначено міграцію як успішну)

---

## 3. Безпечність міграцій

### Основні проблеми при міграціях

1. Блокування таблиці на довгий час - жоден процес не зможе читати та/або писати дані в таблицю, що перебуває в процесі модифікації

2. Неодночасність змін - міграція схеми та використання нової версії програмного забезпечення, що використовує нову схему, ніколи не відбувається одночасно

3. Незмінність міграцій - файли міграцій незмінні, тому якщо допущена помилка в скрипті міграції - її не вийде виправити просто змінивши файл міграції

### Безпечні vs небезпечні операції

Безпечні (швидкі) ALTER:
- Додавання колонки
- Видалення колонки
- Переіменування колонки
- Додавання значення за замовчуванням
- CREATE INDEX CONCURRENTLY

Небезпечні (повільні) ALTER:
- Додавання CHECK / NOT NULL - провокує читання і перевірку всіх даних - може надовго заблокувати таблицю
- Зміна типу колонки - провокує переписування даних - може надовго заблокувати таблицю
- CREATE INDEX - блокує записи протягом створення індексу - може надовго заблокувати таблицю

---

## 4. Багатокроковий реліз (Expand and Contract Pattern або Parallel Change Pattern)

### Проблема

Ситуація: таблиця "orders" нормалізується та розбивається на кілька таблиць. Існує ПЗ, яке активно записує та читає дані в таблиці "orders".

Виниклі проблеми:
1. Якщо нова версія ПЗ залежить від ще не створених табличок - помилка в runtime програми
2. Якщо нова версія ПЗ прочитає дані з нової таблички, але вони ще не мігровані - неконсистентні дані
3. Якщо стара версія ПЗ спробує прочитати дані з уже зміненої таблиці - помилка в runtime

### Рішення: процес багатокрокового релізу

Крок 1 - Додавання нових структур:  
Відбувається перша міграція - додаються нові таблиці, проте існуюча не змінюється

Крок 2 - Подвійний запис:  
Відбувається реліз версії ПЗ, що записує дані і в старому форматі, і в нові таблиці

Крок 3 - Міграція даних:  
Відбувається друга міграція - історичні дані переносяться з існуючої таблиці в нові

Крок 4 - Перехід на читання з нових таблиць:  
Відбувається реліз версії ПЗ, що читає дані ЛИШЕ в новому форматі та з нових таблиць, запис в старому форматі ТА в новому

Крок 5 - Повний перехід:  
Реліз ПЗ з записом ЛИШЕ в новому форматі

Крок 6 - Очищення:  
Відбувається третя міграція - видаляються непотрібні колонки зі старої таблиці

### Переваги багатокрокового релізу

- Перехід на новий формат відбувається без "простою" (downtime) ПЗ
- У будь-який момент ДО кроку 5, якщо щось йде не так, можна повернутись на попередню версію ПЗ і сервіс буде працювати
- Можна виконувати надзвичайно складні міграції значно безпечніше і без значного негативного впливу на роботоспроможність ПЗ

### Недоліки багатокрокового релізу

- Часозатратність - процес вимагає багатьох кроків і багатьох релізів, відповідно перехід на нову версію може займати довгий час (особливо при фіксованому графіку релізів)
- Складність - процес вимагає багатьох кроків та та зачасту розтягнутий в часі

---

## 5. Виправлення помилок міграцій

### Типи міграцій

1. Up міграція - власне міграція, що потрібна
2. Down міграція - "парна" міграція, що скасовує зміни поточної (опціональна)

### Стратегії виправлення помилок

1. Rollback (**не плутати з rollback транзакції!**):
- Додавання окремої "down" міграції, що скасовує поточну
- Застаріла практика

2. Roll forward (рекомендований підхід):
- Створення нової "up" міграції, що виправляє помилку
- Повна відмова від down міграцій
- Наразі вважається більш правильним підходом

---

## 6. DDL та транзакції

### Транзакційність DDL в PostgreSQL

PostgreSQL підтримує транзакційне виконання DDL запитів.

Переваги:
- Вся міграція виконується в одній транзакції як одна неподільна операція
- Можна виконувати кілька змін схеми бази даних та зміни даних атомарно
- Надає всі переваги транзакційності для DDL операцій та міграцій в цілому

Важливо:
- Не всі СУБД підтримують транзакційність для DDL операцій
- У деяких СУБД (наприклад, MySQL) DDL автоматично виконує COMMIT, що не є очевидним
- `CREATE INDEX CONCURRENTLY` не підтримує транзакційність

---

## 7. Міграції даних

### Коли використовувати

Окрім змін схеми баз даних, міграції використовуються для внесення змін до самих даних.

Приклади:
- Великі батчеві оновлення
- Вставка важливих даних (конфігурація, початкові значення)
- Трансформація даних при зміні схеми

Правила:
- З обережністю відноситись до часу виконання запитів, що змінюють дані
- Тестувати на очікуваних обсягах даних перед продакшеном

---

## 8. Практичні поради


1. Міграції НЕЗМІННІ
    - Ніколи не змінюйте вже виконану міграцію
    - Для виправлень створюйте нову міграцію

2. Ідемпотентність
    - Робіть міграції ідемпотентними
    - Багаторазове виконання має давати ідентичний результат одноразовому

3. Тестування
    - Перед виконанням міграції її обов'язково потрібно тестувати
    - Тестувати варто на очікуваних обсягах даних в продакшені
    - Це необхідно для того, щоб оцінити правильність міграції та час її виконання

4. Багатокроковий реліз
    - Варто притримуватись підходів багатокрокового релізу
    - Уникнення конфліктів між ПЗ та схемою бази даних

5. Атомарність міграцій
    - Міграція має містити лише логічно неподільні зміни
    - Краще мати кілька менших міграцій ніж одну велику

6. Зв'язок DDL та даних
    - Зміну DDL та відповідну зміну даних варто тримати в межах однієї міграції
    - Це забезпечує консистентність стану бази даних

---

## 9. Висновки

Міграції баз даних - це критично важливий інструмент для керування змінами в структурі та даних бази даних протягом життєвого циклу проекту. 
Ключові моменти:

- Потрібно розрізняти безпечні та небезпечні ALTER операції
- Завжди варто використовуйте систему міграцій для змін схеми
- Міграції повинні бути незмінними та версіонованими
- Багатокроковий реліз може спростити процес релізу складних змін
- Міграції перед виконанням на продакшені необхідно тестувати
- Для виправлення помилок міграцій краще надавати перевагу підходу "roll forward"
- PostgreSQL підтримує транзакційність DDL операцій

Правильне використання міграцій дозволяє безпечно еволюціонувати структуру бази даних без простоїв ПЗ та втрати даних.

---

## Додаткові матеріали

[Evolutionary Database Design - Martin Fowler](https://martinfowler.com/articles/evodb.html)
[Database Migrations - Vadim Kravcenko](https://vadimkravcenko.com/shorts/database-migrations)
