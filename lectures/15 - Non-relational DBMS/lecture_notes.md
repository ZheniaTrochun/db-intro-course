# Лекція 15: Нереляційні бази даних (NoSQL)

---

## Теми лекції

- Переваги і недоліки реляційних СУБД
- CAP-теорема та масштабування
- Типи нереляційних СУБД
- Вибір типу СУБД під задачу

---

## 1. Переваги реляційних СУБД

Реляційні СУБД на сьогоднішній день є стандартом та вибором за замовчуванням. Їх сильні сторони:

1. ACID - реляційні СУБД надають повну підтримку ACID-властивостей через механізм транзакцій. Якщо транзакція закрита - дані гарантовано збережені.
2. Строга консистентність - структуру таблиць можна нормалізувати. Завдяки нормалізації, дані залишаються консистентними.
3. SQL - стандартизована мова запитів дозволяє виконувати складні запити, join-и між таблицями, агрегації. Зв'язки між таблицями через join-и - це ключова різниця між реляційними і нереляційними СУБД.

---

## 2. Недоліки реляційних СУБД

Реляційні бази також мають ряд обмежень, через які їх використання для певних задач стає непрактичним або неможливим:

1. Складні запити на надзвичайно великих об'ємах даних - реляційні бази справляються з ними набагато повільніше, ніж спеціалізовані альтернативи
2. Висока швидкість і кількість записів - якщо записів значно більше ніж читань і вони відбуваються дуже швидко, реляційні бази можуть не підійти
3. Надвисокі вимоги до швидкодії - є нереляційні бази даних, які працюють швидше і на запис, і на читання
4. Ієрархічні структури даних - в реляційній моделі складно працювати з глибоко ієрархічними/графовими даними
5. Складне масштабування - реляційні бази складно масштабувати горизонтально для запису

---

## 3. CAP-теорема

CAP-теорема - одна з базових теорем розподілених систем. Описує три властивості системи:

- C (Consistency) - консистентність даних: всі клієнти завжди мають найновіші та однакові дані
- A (Availability) - доступність системи: система доступна для читання та запису, навіть у випадку мережевих збоїв
- P (Partition Tolerance) - робота при мережевих збоях: система працює навіть якщо частина серверів втрачає зв'язок

Ключове правило: система може підтримувати лише дві з цих трьох властивостей одночасно.

### Варіанти систем в рамках CAP-теореми

| Комбінація | Поведінка при збоях мережі | Приклади |
|---|---|---|
| C + P | Частина даних стає недоступною, система продовжає працювати | MongoDB, Redis, HBase |
| A + P | Система доступна, але можна отримати застарілі дані | Cassandra, CouchDB, Riak |
| C + A | Система перестає працювати при збоях мережі | PostgreSQL, MySQL |

Реляційні бази даних (C + A) **зазвичай** запускаються в одному екземплярі, через що мережевий збій є в принципі неможливий - система одночасно консистентна і доступна.

---

## 4. Масштабування

Масштабування - процес збільшення потужностей, на яких запущено систему. 
Існує два типи масштабування:
- вертикальне масштабування
- горизонтальне масштабування

### Вертикальне масштабування

Збільшення потужності сервера (CPU, RAM, диск). Спочатку відносно недорого, однак після певної точки вартість росте швидко.  
Вертикальне масштабування має чітку стелю - якщо найпотужнішого доступного обладнання стає недостатньо - масштабування далі неможливе.

### Горизонтальне масштабування

Збільшення кількості серверів і екземплярів системи. Для систем, які ефективно масштабуються горизонтально, можна додавати сотні серверів.  
Більш дешева і гнучка стратегія, яку зазвичай використовують розподілені системи.

### Масштабування реляційних СУБД

- На запис реляційні бази майже не масштабуються горизонтально - розподіл даних на кілька екземплярів (sharding) потрібно робити вручну та це є складним та дороговартісним процесом.
- На читання масштабуються через реплікацію: додаткові копії (репліки) містять ті ж дані, що і основний екземпляр (master), і доступні для читання. Весь набір даних реплікується між всіма екземплярами.

Таким чином, якщо профіль навантаження системи це читання - реляційна база масштабується горизонтально відносно ефективно за допомогою реплікації.  
Якщо ж профіль навантаження системи полягає у величезній кількості записів - потрібно розглядати інші варіанти.

---

## 5. Типи нереляційних СУБД (NoSQL)

### Документні СУБД

Документні СУБД зберігають дані у форматі документів - зазвичай JSON-об'єктів.  
Кожен документ незалежний і може мати різну структуру, різну вкладеність.  
Можна створювати індекси на полях JSON-документів.

Переваги:
- Відсутність схеми - база даних надзвичайно гнучка, можна зберігати будь-яку структуру без змін схеми самої бази
- Підходять для глибоко ієрархічних даних - все збираємо в один JSON-об'єкт без join-ів
- Дані максимально денормалізовані - вибірка за ключем дуже швидка
- Легко масштабуються горизонтально

Недоліки:
- Відсутність схеми - якщо в одній колекції лежать різні типи об'єктів, код для їх обробки стає складним і дуже крихким
- Дублювання даних через денормалізацію - якщо елемент даних відноситься до кількох документів, він зберігається окремо для кожного
- Слабша консистентність - при зміні одного документу потрібно або оновлювати всі інші з тими ж даними, або змиритися з неконсистентністю

Приклади документних СУБД: MongoDB, CouchDB, Firestore, DocumentDB.

MongoDB - найбільш поширена нереляційна СУБД на теперішній момент.

### Ключ-Значення СУБД

Ключ-Значення СУБД зберігають пари ключ-значення, за своєю суттю відповідають хеш-таблицям (аналог словника в Python).  
Ключ - завжди рядок, значення може бути будь-яким типом. Пошук відбувається виключно за ключем.

Переваги:
- Надзвичайно швидкий запис і читання - складність пошуку O(1)
- Дуже проста модель
- Легке горизонтальне масштабування - хеш-таблицю можна розбити на частини і розподілити по різних серверах

Недоліки:
- Читання лише за повним ключем - якщо повного ключа немає, нічого не знайдемо
- Підтримує лише найпростіші операції: get, put, delete - жодних агрегацій і гнучких пошуків

Приклади СУБД: Redis, Hazelcast, Riak.

Особливості Redis:
- Де-факто, стандарт ключ-значення СУБД, найбільш поширений інструмент даного типу
- Зберігає всі дані в оперативній пам'яті (RAM), запис на диск - лише як backup
- Пошук відбувається без читань з диску - лише в памяті - через це надзвичайно швидкий
- Основна вартість запиту - мережевий overhead, сам Redis працює майже моментально
- Часто використовується для кешів з TTL (time-to-live): дані живуть в Redis протягом вказаного часу (наприклад, 30 секунд або 10 хвилин)
- Перезапуск Redis = втрата даних, через це в Redis зберігають ті дані, які не страшно втратити

### Column-Family СУБД

Column-Family (сімейство колонок) СУБД зберігають набори колонок (аналог таблиці).  
Відмінність від реляційних СУБД: немає зв'язків між таблицями і немає підтримки SQL - є лише SELECT за повним ключем.  
Кожна таблиця має чітку схему з primary key, однак без foreign key і check-обмежень.

По суті це розширення концепції ключ-значення: ключ складається з кількох колонок, а значення - це таблиця.

Переваги:
- Надзвичайно швидкий запис і читання
- Майже лінійне масштабування - можна масштабувати і читання, і запис на різні сервери
- Конфігурований рівень консистентності: можна вказати, скільки екземплярів повинні підтвердити запис
- Працюють з неймовірними об'ємами даних (петабайти)

Недоліки:
- Читання лише за повним ключем
- Дуже низька гнучкість запитів
- Схема формується навколо запитів - якщо потрібно читати одні і ті ж дані по-іншому, потрібно записувати їх заново під іншим ключем
- Складно розвивати систему: при зміні паттерна роботи з даними часто потрібна повний перезапис даних

Приклади СУБД:
- Cassandra - золотий стандарт Column-Family СУБД
- ScyllaDB - Cassandra, переписана на C (оригінал написаний на Java)
- HBase - реалізація Column-Family СУБД на основі Hadoop, використовується для роботи з величезними наборами даних

### Графові СУБД

Графові СУБД зберігають дані у вигляді графу - вершин і зв'язків між ними.  
Зв'язки між вершинами можуть мати типи та властивості.  
Використовують особливі мови (не SQL) для роботи з графовими даними.

Переваги:
- Ідеально підходять для даних з великою кількістю зв'язків (наприклад, граф взаємодії людей у соціальній мережі)
- Висока швидкість роботи зі зв'язками між вершинами графу - значно ефективніше, ніж за допомогою таблиць в PostgreSQL
- Надзвичайно гнучка робота зі зв'язками

Недоліки:
- Спеціалізований тип СУБД - не підходить для звичайних табличних даних без складних зв'язків
- Складно масштабуються - аналогічно до реляційних СУБД

Приклади СУБД: Neo4j, Amazon Neptune.

### Пошукові рушії

Пошукові рушії - СУБД, спеціалізовані для повнотекстового пошуку.  
Працюють на основі розбивки тексту на окремі токени (слова, словосполучення) і формування індексів документів на основі цих токенів.

Переваги:
- Ефективний повнотекстовий пошук по великих масивах текстових даних
- Висока гнучкість ранжування результатів - функцію ранжування можна конфігурувати

Недоліки:
- Індексація тексту займає час - дані після вставки не одразу доступні для пошуку (є затримка)
- Ресурсоємні і часто примхливі - при великій кількості документів споживання пам'яті росте, масштабування може бути дорогим

Приклади: ElasticSearch, Apache Solr, OpenSearch.

Поширений приклад використання - логи застосунку: якщо застосунок запущений в кількох екземплярах, читати логи з терміналу складно, тому їх кладуть в пошуковий рушій (зазвичай ElasticSearch) і потім шукати по ним можна дуже гнучко та ефективно.

### Колонкові СУБД

Колонкові СУБД зберігають дані у форматі таблиць, однак кожна колонка зберігається в окремому файлі з окремими сторінками і метаданими.  
Немає зв'язків між таблицями та CHECK обмежень, однак колонкові СУБД підтримують більшу частину стандарту SQL, що відноситься до SELECT запитів.

Переваги:
- Ефективні для аналітичних SQL-запитів - робота з OLAP трафіком це основне їх призначення
- Дуже гнучко масштабуються - масштабування обчислювальних потужностей відбувається незалежно від об'єму даних
- Працюють з дуже великими об'ємами даних - дані часто зберігаються окремо від обчислювальних потужностей (наприклад, в дешевому cloud storage, такому як S3)

Недоліки:
- Висока вартість - оренда cloud-потужностей колонкових баз даних може бути дорогою
- Відсутність зв'язків між таблицями та CHECK обмежень
- Низька швидкість роботи з OLTP запитами та висока вартість кожного з запитів, робить використання колонкових баз даних для OLTP трафіку нераціональним

Приклади СУБД: Snowflake, Amazon Redshift, Google Big Query.

---

## 6. Вибір типу СУБД

### Коли обирати реляційну СУБД

Варто обирати реляційні СУБД коли:

1. Необхідна строга консистентність та ACID - нереляційні СУБД надають лише обмежений набір гарантій
2. Відносно складні запити з гнучким пошуком (не лише за ключем)
3. Необхідні зв'язки між таблицями - це один з ключових "killer feature" реляційних СУБД
4. Консистентність важливіша за доступність
5. Немає необхідності використовувати нереляційну СУБД

### Коли обирати нереляційну СУБД

Варто обирати нереляційні СУБД коли:

1. Необхідне горизонтальне масштабування на запис
2. Висока кількість записів
3. Вимоги до надвисокої швидкодії
4. Доступність важливіша за консистентність
5. Є необхідність використання спеціалізованого типу СУБД (графові дані, повнотекстовий пошук, аналітика на терабайтах і більше даних)

---

## 7. Рекомендації щодо вибору СУБД

1. Завжди починати з реляційної СУБД - з реляційними базами значно простіше працювати. Якщо на початку проєкту обрати складну нереляційну СУБД, більше часу витрачаємо на роботу з базою і відповідно менше часу залишається на реалізацію функціоналу.

2. Мінімізувати кількість різних СУБД в проекті - якщо на проекті вже використовується PostgreSQL, варто адаптуватись під нього. Наприклад, для зберігання неструктуровованих об'єктів можна додати колонку типу `jsonb` в PostgreSQL, а не додавати нову технологію, таку як MongoDB.

3. Виключення - ключ-значення СУБД - Redis часто додають окремо навіть якщо PostgreSQL вже використовується, бо він дуже простий в підтримці і надзвичайно швидкий для кешу.

4. Переходити на нереляційні СУБД лише тоді, коли є необхідність - на практиці зазвичай використовуються і реляційні, і нереляційні в рамках однієї системи. Приклад: основні дані в PostgreSQL, логи в ElasticSearch, аналітичні дані в колонковій базі, кеш в Redis.

Виключення для навчальних проектів: для навчальних проектів логічно вибирати ті технології, які хочете вивчити. Для реальних проектів - починати з **простого** і переходити до складніших інструментів **лише тоді, коли є необхідність**.

---

## 8. Висновки

Нереляційні бази даних - це спеціалізовані інструменти, кожен з яких розв'язує свою задачу:

- Реляційні СУБД залишаються стандартом за замовчуванням через підтримку ACID, строгу консистентність і зв'язки між таблицями
- CAP-теорема описує обмеження будь-якої розподіленої системи - можна підтримувати лише дві з трьох властивостей
- Горизонтальне масштабування - основна причина переходу на NoSQL, реляційні СУБД погано масштабуються на запис горизонтально
- Документні СУБД (MongoDB) - для ієрархічних, денормалізованих даних без складних зв'язків
- Ключ-Значення СУБД (Redis) - для кешів і даних, які потрібно читати/писати надзвичайно швидко
- Column-Family СУБД (Cassandra) - для великих об'ємів даних з лінійним масштабуванням
- Графові СУБД (Neo4j) - для графових даних з великою кількістю зв'язків
- Пошукові рушії (ElasticSearch) - для повнотекстового пошуку
- Колонкові СУБД (Snowflake) - для аналітичних запитів на великих об'ємах даних
- Завжди варто починати з реляційної СУБД і переходити на нереляційні лише при наявності конкретної необхідності

---

## 9. Додаткові ресурси

- [Understanding the CAP Theorem: Balancing Consistency, Availability, and Partition](https://medium.com/@ngneha090/understanding-the-cap-theorem-balancing-consistency-availability-and-partition-cb11c2b97e2b)
- [CAP Theorem Explained](https://www.nitendratech.com/database/cap-theorem/)
- [What is NoSQL](https://www.mongodb.com/resources/basics/databases/nosql-explained)
- [What are Vector Databases](https://www.mongodb.com/resources/basics/databases/vector-databases)
- [What is Redis and how does it work Internally](https://medium.com/@ayushsaxena823/what-is-redis-and-how-does-it-work-cfe2853eb9a9)
- [MongoDB](https://www.mongodb.com/docs/manual/)
- [Cassandra Basics](https://cassandra.apache.org/_/cassandra-basics.html)
- [What is Graph Database](https://neo4j.com/docs/getting-started/graph-database/)
- [Elastic Search 101](https://medium.com/@abhirup.acharya009/elastic-search-101-demystifying-elasticsearch-53bff5d0b097)
- [Columnar Databases vs. Row-Oriented Databases](https://www.tigerdata.com/learn/columnar-databases-vs-row-oriented-databases-which-to-choose)