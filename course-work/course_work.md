# Методичні рекомендації до курсової роботи

## Загальний огляд

Ця курсова робота базується на знаннях та навичках, які ви отримали під час виконання лабораторних робіт. Ви розробите backend-додаток, який демонструє ваше розуміння проектування баз даних та SQL-запитів.

Ключові завдання:
- Застосувати концепції з лабораторних занять у повноцінному проекті
- Виконати завдання індивідуально або в групах (до 4 осіб)
- Обрати будь-яку предметну область чи тему, яка вас цікавить 

---

## Цілі проєкту

Виконавши цю курсову роботу, ви зможете:
- Спроєктувати нормалізовану схему реляційної бази даних
- Реалізувати складні операції з базою даних з правильною обробкою транзакцій
- Написати як прості, так і аналітичні SQL-запити
- Ефективно використовувати ORM / SQL builder-и
- Застосувати контейнеризацію
- Написати тести для операцій з базою даних
- Задокументувати вашу роботу

---

## Технічні вимоги

### Необхідні технології

| Технологія | Вимога |
|------------|--------|
| База даних | PostgreSQL (будь-яка актуальна версія) |
| ORM/SQL Builder | На ваш вибір - див. варіанти нижче |
| Мова програмування | Без обмежень - використовуйте ту, з якою комфортно |
| Контейнеризація | Docker Compose |

### Популярні варіанти ORM/SQL Builder за мовами

- Python: SQLAlchemy, Django ORM, Peewee
- JavaScript/TypeScript: Prisma, TypeORM, Sequelize, Knex.js
- Java: Hibernate, jOOQ, MyBatis
- C#: Entity Framework Core, Dapper
- Go: GORM, sqlx, Ent
- Rust: Diesel, SQLx, SeaORM

Обирайте на основі вашого рівня комфорту з конкретною технологією та досвіду.

---

## Функціональні вимоги

### Схема бази даних

Ваша база даних повинна включати:
- Мінімум 5-7 пов'язаних таблиць, що представляють обрану предметну область
- 3НФ - третя нормальна форма
- Коректні типи даних для всіх стовпців
- Первинні ключі в усіх таблицях
- Зовнішні ключі з правильними обмеженнями
- Щонайменше 2-3 індекси
- CHECK-обмеження

### Необхідні операції

#### 1. Комплексні сценарії створення сутностей (кожен з учасників проекту повинен розробити МІНІМУМ 1 сценарій)

Кожен сценарій повинен демонструвати:
- Створення кількох пов'язаних сутностей в одній операції
- Транзакційність
- Валідацію даних перед вставкою
- Обробку помилок (зовнішні ключі, унікальні обмеження)
- Правильну обробку помилок та ROLLBACK при збоях

Приклади сценаріїв:
- Створення замовлення з кількома товарами та оновленням запасів
- Реєстрація користувача з профілем, налаштуваннями та початковими параметрами
- Бронювання зустрічі з розподілом ресурсів та сповіщеннями

Що потрібно продемонструвати:
```
Кілька операцій INSERT в одній транзакції
Логіка валідації даних
Зовнішні ключі
Обробка помилок (що станеться, якщо валідація не пройде?)
Повернення повної створеної сутності з пов'язаними даними
```

#### 2. Сценарії оновлення сутностей (кожен з учасників проекту повинен розробити МІНІМУМ 1 сценарій)

Кожен сценарій повинен демонструвати:
- Оновлення на основі поточного стану сутності
- Оптимістичне або песимістичне блокування
- Оновлення пов'язаних сутностей (за необхідності)
- Транзакційність
- Валідацію умов оновлення

Приклади сценаріїв:
- Оновлення статусу замовлення з узгодженням інвентаризації
- Перенесення зустрічі з перевіркою конфліктів
- Оновлення інформації про продукт з відстеженням історії цін

Що потрібно продемонструвати:
```
Операції UPDATE з умовами WHERE
Перевірка поточного стану перед оновленням
Обробка race conditions (що якщо двоє користувачів оновлюють одночасно?)
Каскадні оновлення пов'язаних таблиць за потреби
Правильні повідомлення про помилки для недійсних оновлень
```

#### 3. Сценарій видалення сутностей (кожен з учасників проекту повинен розробити МІНІМУМ 1 сценарій)

Ви повинні реалізувати жорстке видалення, soft delete **або** обидва типи

Жорстке видалення (hard delete):
- Фізичне видалення записів з бази даних (DELETE)
- Правильна обробка каскадного видалення пов'язаних записів
- Підтримка референтйної цілісності (foreign keys)

М'яке видалення (soft delete):
- Позначення записів як видалених (наприклад, timestamp `deleted_at` або прапорець `is_deleted` та поле `updated_at`)
- Фільтрація видалених записів з регулярних запитів

Приклади сценаріїв:
- Жорстке видалення: Видалення скасованого замовлення до обробки
- М'яке видалення: Деактивація облікового запису користувача (збереження даних для аналітики)
- Жорстке видалення: Видалення прострочених тимчасових даних
- М'яке видалення: Архівування завершених проєктів

Що потрібно продемонструвати:
```
Жорстке або м'яке видалення з правильною поведінкою CASCADE
Обробка зовнішніх ключів
Очищення пов'язаних даних де доречно
```

#### 4. Прості SELECT-запити (кожен з учасників проекту повинен розробити МІНІМУМ 2 сценарії)

Базові операції отримання даних, що включають:
- Фільтрацію за допомогою WHERE-умов
- Прості JOIN (1-2 таблиці)
- Сортування (ORDER BY)
- Пагінацію (LIMIT/OFFSET)

Приклади запитів:
```sql
-- 1. Фільтрація за однією умовою з сортуванням
SELECT * FROM products 
WHERE category_id = ? 
ORDER BY price DESC;

-- 2. Фільтрація з кількома умовами
SELECT * FROM users 
WHERE is_active = true 
  AND created_at > '2024-01-01'
LIMIT 20 OFFSET 0;

-- 3. Простий JOIN з фільтром
SELECT orders.*, customers.name 
FROM orders 
JOIN customers ON orders.customer_id = customers.id
WHERE orders.status = 'pending';

-- 4. Шаблон пошуку
SELECT * FROM articles 
WHERE title LIKE '%database%' 
  OR content LIKE '%database%';
```

#### 5. Складні аналітичні запити (кожен з учасників проекту повинен розробити МІНІМУМ 1 сценарій)

Повинні включати **частину** наступних вимог:
- Агрегатні функції (COUNT, SUM, AVG, MIN, MAX)
- GROUP BY з умовами HAVING
- Кілька JOIN (3+ таблиці)
- Підзапити або CTE (Common Table Expressions)
- Віконні функції

Приклади запитів:
```sql
-- Щомісячний звіт про продажі за категоріями
SELECT 
    c.name as category,
    DATE_TRUNC('month', o.created_at) as month,
    COUNT(DISTINCT o.id) as order_count,
    SUM(oi.quantity * oi.price) as total_revenue
FROM orders o
JOIN order_items oi ON o.id = oi.order_id
JOIN products p ON oi.product_id = p.id
JOIN categories c ON p.category_id = c.id
WHERE o.status = 'completed'
GROUP BY c.name, DATE_TRUNC('month', o.created_at)
HAVING SUM(oi.quantity * oi.price) > 1000
ORDER BY month DESC, total_revenue DESC;

-- Топ-3 продукти за категоріями по продажах
WITH product_sales AS (
    SELECT 
        p.id,
        p.name,
        p.category_id,
        SUM(oi.quantity * oi.price) as total_sales,
        ROW_NUMBER() OVER (
            PARTITION BY p.category_id 
            ORDER BY SUM(oi.quantity * oi.price) DESC
        ) as rank_in_category
    FROM products p
    JOIN order_items oi ON p.id = oi.product_id
    GROUP BY p.id, p.name, p.category_id
)
SELECT * FROM product_sales
WHERE rank_in_category <= 3;

-- Аналіз життєвої цінності клієнта
WITH customer_stats AS (
    SELECT 
        c.id,
        c.name,
        COUNT(DISTINCT o.id) as order_count,
        SUM(oi.quantity * oi.price) as total_spent,
        AVG(oi.quantity * oi.price) as avg_order_value,
        MIN(o.created_at) as first_order,
        MAX(o.created_at) as last_order
    FROM customers c
    JOIN orders o ON c.id = o.customer_id
    JOIN order_items oi ON o.id = oi.order_id
    WHERE o.status = 'completed'
    GROUP BY c.id, c.name
)
SELECT 
    *,
    EXTRACT(DAY FROM (last_order - first_order)) as customer_lifetime_days,
    CASE 
        WHEN order_count >= 10 THEN 'VIP'
        WHEN order_count >= 5 THEN 'Regular'
        ELSE 'Occasional'
    END as customer_tier
FROM customer_stats
WHERE total_spent > 100
ORDER BY total_spent DESC;
```

Ваші аналітичні запити повинні відповідати на бізнес-питання по типу:
- Які наші найуспішніші продукти/категорії/користувачі?
- Як метрики порівнюються між часовими періодами?
- Які закономірності існують у поведінці користувачів?
- Які сутності мають зростаючий або спадний тренд?
- Які існують зв'язки між різними метриками?

---

## Вимоги до тестування

### Очікування щодо покриття тестами

Ваші тести повинні охоплювати:
- Всі операції з базою даних (сценарії створення, читання, оновлення, видалення)
- Результати складних запитів (перевірка, що аналітичні запити повертають правильні дані)
- Обробку помилок
- Поведінку транзакцій (відкат при помилках)

### Необхідні типи тестів

#### 1. Інтеграційні тести (основний фокус)
Тестування реальних операцій з базою даних:
```python
# Приклад на Python з pytest
def test_create_order_with_items(db_session):
    # Підготовка
    customer = create_test_customer(db_session)
    products = create_test_products(db_session, count=3)
    
    # Виконання
    order = create_order_with_items(
        customer_id=customer.id,
        items=[
            {"product_id": products[0].id, "quantity": 2},
            {"product_id": products[1].id, "quantity": 1}
        ]
    )
    
    # Перевірка
    assert order.id is not None
    assert len(order.items) == 2
    assert order.total_amount == expected_total
    
    # Перевірка зменшення інвентаря
    updated_product = get_product(products[0].id)
    assert updated_product.stock == original_stock - 2
```

#### 2. Модульні тести (допоміжні)
Тестування бізнес-логіки без бази даних:
```python
def test_calculate_order_total():
    items = [
        {"price": 10.00, "quantity": 2},
        {"price": 15.50, "quantity": 1}
    ]
    total = calculate_total(items)
    assert total == 35.50
```

#### 3. Тести сценаріїв збою
```python
def test_create_order_insufficient_stock(db_session):
    product = create_test_product(db_session, stock=1)
    
    with pytest.raises(InsufficientStockError):
        create_order_with_items(
            customer_id=1,
            items=[{"product_id": product.id, "quantity": 5}]
        )
    
    # Перевірка відсутності часткових змін
    assert get_order_count() == 0
```

### Рекомендації щодо тестів

- Очищайте базу даних між тестами (rollback транзакції або truncate table)
- Використовуйте окрему тестову базу даних
- Створюйте тестові сценарії, що відображають реальні випадки використання

---

## Вимоги до Docker

### Структура docker-compose.yml

Ваш `docker-compose.yml` повинен включати:
- Сервіс PostgreSQL з правильною конфігурацією
- Змінні середовища для підключення до бази даних
- Volume для збереження даних
- Контейнер додатку
---

## Структура проєкту

### Рекомендована структура каталогів

```
coursework/
├── docker-compose.yml          # Конфігурація Docker
├── Dockerfile                  # Конфігурація контейнера додатку
├── .gitignore                 # Ігнорувати .env, node_modules, __pycache__ тощо
├── README.md                  # Основна документація
│
├── docs/                      # Додаткова документація
│   ├── schema.md              # Пояснення схеми бази даних
│   ├── queries.md             # Складні запити з поясненнями
│   └── architecture.md        # Опціонально: дизайн системи
│
├── migrations/                # Міграції бази даних
│   ├── 001_initial_schema.sql
│   ├── 002_add_indexes.sql
│   └── ...
│
├── src/                       # Вихідний код
│   ├── models/                # Моделі ORM / визначення сутностей
│   │   ├── user.py
│   │   ├── order.py
│   │   └── ...
│   │
│   ├── repositories/          # Шар доступу до даних
│   │   ├── user_repository.py
│   │   ├── order_repository.py
│   │   └── ...
│   │
│   ├── services/              # Бізнес-логіка
│   │   ├── order_service.py
│   │   └── ...
│   │
│   └── ...
│
├── test/                     # Тестові файли
│   ├── integration/          # Інтеграційні тести
│   │   ├── test_order_creation.py
│   │   ├── test_user_updates.py
│   │   └── ...
│   └── unit/                 # Модульні тести
│       └── test_validators.py
│
└── ...
```

Примітки:
- Адаптуйте структуру до coding-практик обраної мови
- Тримайте бізнес-логіку окремо від доступу до даних
- Організовуйте програмний код за фічами/функціоналом або за шарами - будьте послідовні

---

## Вимоги до документації

### 1. README.md (Основна документація)

Ваш README повинен включати:

#### Назва проєкту та опис
- Назва проєкту
- Короткий опис предметної області/призначення
- Члени команди

#### Технологічний стек
- Мова програмування та версія
- Бібліотека ORM/SQL builder
- Фреймворк тестування

#### Інструкції з налаштування
```markdown
1. Клонуйте репозиторій
2. Запустіть сервіси: `docker-compose up -d`
...
```

#### Запуск додатку

#### Запуск тестів
- Запустити всі тести
- Запустити конкретний тестовий файл

#### Огляд структури проєкту
Коротке пояснення організації каталогів

#### Приклади API/використання

### 2. docs/schema.md (Документація схеми бази даних)

Включає:

#### Діаграма сутність-зв'язок (ERD)

#### Опис таблиць
Для кожної таблиці:
```markdown
### Таблиця: `users`

Призначення: Зберігає інформацію про облікові записи користувачів

Стовпці:
| Стовпець | Тип | Обмеження | Опис |
|----------|-----|-----------|------|
| id | SERIAL | PRIMARY KEY | Ідентифікатор користувача |
| email | VARCHAR(255) | UNIQUE, NOT NULL | Email користувача |
| password_hash | VARCHAR(255) | NOT NULL | Хешований пароль |
| created_at | TIMESTAMP | DEFAULT NOW() | Час створення облікового запису |
| deleted_at | TIMESTAMP | NULL | Мітка часу м'якого видалення |

Індекси:
- `idx_users_email` на `email` (для пошуку при вході)

Зв'язки:
- Один-до-багатьох з `orders` (користувач може мати кілька замовлень)
```

#### Рішення щодо дизайну
Поясніть:
- Чому ви обрали цю структуру схеми
- Досягнутий рівень нормалізації
- Зроблені компроміси
- Стратегія індексування

### 3. docs/queries.md (Документація складних запитів)

Для кожного аналітичного запиту надайте:

```markdown
### Запит 1: Щомісячний дохід за категоріями

Бізнес-питання: 
Який наш щомісячний розподіл доходу за категоріями продуктів?

SQL-запит:
[Ваш фактичний SQL тут]

Пояснення:
- JOIN таблиць orders, order_items, products та categories
- Групування за місяцем та категорією
- Обчислення загального доходу на групу
- Фільтрація лише завершених замовлень
- Сортування результатів хронологічно

Приклад виводу:
| category | month | order_count | total_revenue |
|----------|-------|-------------|---------------|
| Електроніка | 2024-01 | 45 | 15,320.50 |
| Книги | 2024-01 | 120 | 3,450.25 |
...
```

---

## Вибір вашої предметної області

У вас є повна свобода вибору будь-якої предметної області, яка вас цікавить.

Характеристики хорошої предметної області:
- Ви розумієте бізнес-логіку
- Має чіткі зв'язки між сутностями
- Дозволяє створювати цікаві запити
- Мотивує вас завершити проєкт

---

## Рекомендації щодо групової роботи

### Розмір команди
Очікуваний ромір команд - 1-4 людини.  
Проте для реалізації більш комплексних проектів можливо залучення і більшої кількості учасників.  
Якщо Ви бажаєте розробляти проект з більшою кількістю учасників - це потрібно узгодити з лектором.

### Рекомендації щодо співпраці

Якщо працюєте в групі:

1. Правильно використовуйте Git:
   - Створіть спільний репозиторій (GitHub, GitLab тощо)
   - Використовуйте гілки та pull request
   - Чіткий опис комітів

2. Розподіліть роботу справедливо:
   - Кожен учасник реалізує щонайменше одну операцію кожного типу
   - Поділіть відповідальність за тестування

3. Документуйте внески:
   - Додайте файл `CONTRIBUTIONS.md`, що перелічує, хто що зробив
   ```markdown
   # Внески команди
   
   ## Учасник 1: Антон
   - Реалізував створення та оновлення замовлень
   - Написав аналітичний запит аналізу доходу
   - Інтеграційні тести для операцій із замовленнями
   - Налаштування Docker та документація
   
   ## Учасник 2: Юлія
   - Реалізувала управління користувачами
   - Написала аналітичні запити ... та ...
   - Інтеграційні тести для ... 
   - Створення репозиторію та документація
   ```

4. Комунікація:
    - Регулярні зустрічі команди
    - Чіткі призначення завдань
    - Code review

### Індивідуальна відповідальність

Навіть у групах:
- Кожен учасник повинен розуміти **весь** код
- Кожен учасник має вміти пояснити будь-яку частину проекту
- Ніяких "Я робив тільки X частину" - ви відповідальні за весь проєкт

---

## Критерії оцінювання

Ваша курсова робота буде оцінюватися за:

### 1. Дизайн бази даних (20%)
- Коректна структура таблиць
- Нормалізація (3НФ)
- Правильне використання обмежень (PK, FK, UNIQUE, CHECK)
- Добре спроєктовані зв'язки
- Відповідні типи даних
- Індексування
- ER Діаграма

### 2. Якість реалізації (25%)
- Всі необхідні операції реалізовані правильно
- Правильне використання ORM/SQL builder
- Транзакції
- Обробка помилок
- Організація та структура коду
- Послідовний стиль коду
- Відсутність вразливостей SQL-ін'єкцій

### 3. Запити (25%)
- Всі прості запити працюють правильно
- Складні аналітичні запити демонструють володіння SQL
- Правильне використання JOIN, агрегацій, віконних функцій
- Запити відповідають на значущі бізнес-питання
- Ефективний дизайн запитів
- CTE або підзапити використані доречно

### 4. Тестування (10%)
- Вичерпне покриття тестами (70%+ бізнес-логіки)
- Інтеграційні тести для всіх операцій
- Протестовані сценарії помилок
- Тести є значущими та добре організованими
- Всі тести проходять

### 5. Docker та налаштування середовища (5%)
- docker-compose.yml працює правильно
- Легко налаштувати та запустити
- Правильне використання змінних середовища
- Міграції бази даних працюють
- Сервіси запускаються надійно

### 6. Документація (15%)
- Чіткий та повний README
- Інструкції з налаштування точні
- Схема бази даних задокументована
- Складні запити пояснені
- Надані приклади використання

Бонусні бали:
- Особливо елегантні рішення
- Додаткові функції понад вимоги
- Відмінна якість коду
- Креативний вибір предметної області з цікавими запитами

---

## Ресурси та допомога

### Посилання на документацію
- Документація PostgreSQL: https://www.postgresql.org/docs/
- Документація Docker Compose: https://docs.docker.com/compose/

### Документація ORM (оберіть відповідно до вашої мови)
- SQLAlchemy (Python): https://docs.sqlalchemy.org/
- Prisma (JS/TS): https://www.prisma.io/docs
- TypeORM (JS/TS): https://typeorm.io/
- JOOQ (Java): https://www.jooq.org/learn/
- Hibernate (Java): https://hibernate.org/orm/documentation/
- GORM (Go): https://gorm.io/docs/

---

## Рекомендації щодо здачі

### Що здавати

1. Репозиторій
    - Git-репозиторій (посилання на GitHub/GitLab)
    - Включіть весь код, міграції, тести
    - Включіть docker-compose.yml та Dockerfile

2. Документація
    - README.md (у репозиторії)
    - Папка docs/ з документацією схеми та запитів
    - CONTRIBUTIONS.md (якщо групова робота)

3. Демо-дані (опціонально, але рекомендовано)
    - SQL-скрипт для заповнення тестових даних
    - Інструкції для генерації тестових даних

### Як здавати

1. Заповнити форму - надати посилання на репозиторій та склад команди (якщо не маєте посилання на форму - написати лектору в ТГ).
2. Записатись на короткий дзвінок-співбесіду з лектором (~10-15 хвилин).
3. На дзвінку презентувати проект та Ваш персональний внесок.

### Перед здачею перевірте, що:

- Весь код закомічений та запушений
- `docker-compose up` працює
- Всі тести проходять
- Повна документація
  - Схема бази даних задокументована
  - Складні запити пояснені
  - Групові внески задокументовані

### Термін здачі
**До кінця залікового тижня**

---

## Поради

1. Регулярно комітьте
2. Тестуйте по ходу розробки - не залишайте всі тести на кінець
3. Просіть допомоги чи поради, якщо щось не виходить
4. Документуйте під час розробки
5. Оберіть предметну область, яка вас цікавить - це зробить роботу приємнішою

Пам'ятайте: Ціль цієї курсової роботи - зрозуміти основні концепції роботи з базами даних та навчитись їх застосовувати на практиці. Тому якщо щось не зрозуміло чи не виходить - краще запитати. 
